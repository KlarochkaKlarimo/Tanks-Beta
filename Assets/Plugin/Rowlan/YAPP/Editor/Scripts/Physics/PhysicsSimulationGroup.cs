using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

namespace Rowlan.Yapp
{
    public class PhysicsSimulationGroup : ScriptableObject
    {
        private PhysicsSettings physicsSettings;

        private SimulatedBody[] simulatedBodies;
         
        private List<Rigidbody> generatedRigidbodies;
        private List<Collider> generatedColliders;
        private List<Collider> nonConvexColliders;

        private Transform[] simulatedGameObjects = null;

        private bool initialForceApplied;

        public void ApplySettings(PhysicsSettings physicsSettings)
        {
            this.physicsSettings = physicsSettings;

        }

        public void ApplyForce()
        {
            // Add force to bodies
            foreach (SimulatedBody body in simulatedBodies)
            {
                float randomForceAmount = Random.Range(physicsSettings.forceMinMax.x, physicsSettings.forceMinMax.y);
                float forceAngle = body.forceAngle;
                Vector3 forceDir = new Vector3(Mathf.Sin(forceAngle), 0, Mathf.Cos(forceAngle));
                body.rigidbody.AddForce(forceDir * randomForceAmount, ForceMode.Impulse); 
            }
        }

        #region Simulate Continuously

        Dictionary<Collider, HideFlags> colliderFlagsMap = null;

        public void StartSimulation(Transform[] gameObjects)
        {
            Debug.Log("Simulation objects added: " + gameObjects.Length);

            this.simulatedGameObjects = gameObjects;

            // store eg collider flags, generate colliders for gameobjects which don't have them
            PreProcessSimulation();

            simulatedBodies = gameObjects.Select(rb => new SimulatedBody(rb, physicsSettings.forceAngleInDegrees, physicsSettings.randomizeForceAngle)).ToArray();

            PhysicsSimulator.RegisterGroup(this); 
        }

        public void PreProcessSimulation()
        {
            nonConvexColliders = new List<Collider>();

            // store the hide flags for the colliders
            colliderFlagsMap = new Dictionary<Collider, HideFlags>();

            foreach (Transform transform in simulatedGameObjects)
            {
                Collider[] colliders = transform.GetComponentsInChildren<Collider>();

                foreach (Collider collider in colliders)
                {
                    colliderFlagsMap.Add(collider, hideFlags);

                    // hide the colliders in the hierarchy
                    collider.hideFlags = HideFlags.HideInHierarchy;

                    // check convexity
                    if( collider is MeshCollider && !((MeshCollider) collider).convex)
                    {
                        nonConvexColliders.Add(collider);

                        ((MeshCollider)collider).convex = true;
                    }
                        
                }
            }

            // generate eg colliders for gameobjects which don't have them
            AutoGenerateComponents();

            // backup all rigidbody settings which we don't want to be affected by the physics simulation
            PhysicsFilter.Backup(simulatedGameObjects);
        }

        private void PostProcessSimulation()
        {
            // remove auto generated rigidbodies and colliders
            RemoveAutoGeneratedComponents();

            // restore the hide flags
            foreach (Transform transform in simulatedGameObjects)
            {
                // prevent exception; could be that the object was destroyed during an undo operation
                if (transform == null)
                    continue;

                Collider[] colliders = transform.GetComponentsInChildren<Collider>();
                foreach (Collider collider in colliders)
                {
                    HideFlags hideFlags;
                    if (colliderFlagsMap.TryGetValue(collider, out hideFlags))
                    {
                        collider.hideFlags = hideFlags;
                    }

                    // restore convexity
                    if (collider is MeshCollider && nonConvexColliders.Contains( collider))
                    {
                        ((MeshCollider)collider).convex = false;
                    }
                }
            }

            // clear the hide flags map
            colliderFlagsMap = null;

            nonConvexColliders = null;

        }

        public void CleanUp()
        {
            PostProcessSimulation();
        }

        public void PerformSimulateStep()
        {
            // apply initial force if necessary
            if (physicsSettings.forceApplyType == PhysicsSettings.ForceApplyType.Initial && !initialForceApplied)
            {
                ApplyForce();

                initialForceApplied = true;
            }
            // apply force if necessary
            if (physicsSettings.forceApplyType == PhysicsSettings.ForceApplyType.Continuous)
            {
                ApplyForce();
            }
        }
        #endregion Simulate Continuously

        // Automatically add rigidbody and box collider to object if it doesn't already have
        void AutoGenerateComponents()
        {
            generatedRigidbodies = new List<Rigidbody>();
            generatedColliders = new List<Collider>();

            foreach (Transform child in simulatedGameObjects)
            {
                // add rigidbody; LODGroup children don't need it
                if (!child.GetComponent<Rigidbody>())
                {
                    AddGeneratedRigidbody(child);
                }

                // add collider to transform and LODGroup child
                if (!child.GetComponent<Collider>())
                {
                    // child
                    AddGeneratedCollider(child);

                    // lod group child: collider is at child with index 0 (note not the lod group index yet, could be improved if need be, but iteration takes performance)
                    LODGroup lodGroup = child.GetComponent<LODGroup>();
                    if ( lodGroup != null && lodGroup.lodCount > 0)
                    {
                        Transform lodChild = child.GetChild(0);

                        if (!lodChild.GetComponent<Collider>())
                        {
                            AddGeneratedCollider(lodChild);
                        }
                            
                    }
                }
            }
        }

        /// <summary>
        /// Add temporary rigidbody and register it
        /// </summary>
        /// <param name="transform"></param>
        private void AddGeneratedRigidbody(Transform transform)
        {
            Rigidbody rb = transform.gameObject.AddComponent<Rigidbody>();

            rb.useGravity = true;
            rb.mass = 1;

            rb.collisionDetectionMode = physicsSettings.collisionDetectionMode;

            generatedRigidbodies.Add(rb);
        }

        /// <summary>
        /// Add temporary collider and register it
        /// </summary>
        /// <param name="transform"></param>
        private void AddGeneratedCollider( Transform transform)
        {
            MeshCollider collider = transform.gameObject.AddComponent<MeshCollider>();
            collider.convex = true;

            // hide colliders in the hierarchy, they cost performance
            collider.hideFlags = HideFlags.HideInHierarchy;

            generatedColliders.Add(collider);

        }

        // Remove the components which were generated at start of simulation
        void RemoveAutoGeneratedComponents()
        {
            foreach (Rigidbody rb in generatedRigidbodies)
            {
                DestroyImmediate(rb);
            }
            foreach (Collider c in generatedColliders)
            {
                DestroyImmediate(c);
            }
        }

        public void UndoSimulation()
        {
            if (simulatedBodies != null)
            {
                foreach (SimulatedBody body in simulatedBodies)
                {
                    body.Undo();
                }
            }
        }

        struct SimulatedBody
        {
            public readonly Rigidbody rigidbody;

            readonly Geometry geometry;
            readonly Transform transform;

            public readonly float forceAngle;

            public SimulatedBody(Transform transform, float forceAngleInDegrees, bool randomizeForceAngle)
            {
                this.transform = transform;
                this.rigidbody = transform.GetComponent<Rigidbody>();

                this.geometry = new Geometry(transform);

                this.forceAngle = ((randomizeForceAngle) ? Random.Range(0, 360f) : forceAngleInDegrees) * Mathf.Deg2Rad;
            }

            public void Undo()
            {
                // check if the transform was removed manually
                if (transform == null)
                    return;

                transform.position = geometry.getPosition();
                transform.rotation = geometry.getRotation();

                if (rigidbody != null)
                {
                    rigidbody.velocity = Vector3.zero;
                    rigidbody.angularVelocity = Vector3.zero;
                }
            }
        }
    }
}